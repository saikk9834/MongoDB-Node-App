"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const jsYaml = require("js-yaml");
const path = require("path");
const json_ref_schema_1 = require("./json.ref.schema");
const openapi_schema_validator_1 = require("./openapi.schema.validator");
const base_path_1 = require("./base.path");
class OpenAPIFramework {
    constructor(args) {
        this.loggingPrefix = 'openapi.validator: ';
        this.apiDoc = this.copy(this.loadSpec(args.apiDoc));
        this.basePathObs = this.getBasePathsFromServers(this.apiDoc.servers);
        this.basePaths = Array.from(this.basePathObs.reduce((acc, bp) => {
            bp.all().forEach(path => acc.add(path));
            return acc;
        }, new Set()));
        this.validateApiDoc =
            'validateApiDoc' in args ? !!args.validateApiDoc : true;
        this.validator = new openapi_schema_validator_1.OpenAPISchemaValidator({
            version: this.apiDoc.openapi,
        });
        if (this.validateApiDoc) {
            const apiDocValidation = this.validator.validate(this.apiDoc);
            if (apiDocValidation.errors.length) {
                console.error(`${this.loggingPrefix}Validating schema`);
                console.error(`${this.loggingPrefix}validation errors`, JSON.stringify(apiDocValidation.errors, null, '  '));
                throw new Error(`${this.loggingPrefix}args.apiDoc was invalid.  See the output.`);
            }
        }
    }
    initialize(visitor) {
        const getApiDoc = () => {
            return this.copy(this.apiDoc);
        };
        this.sortApiDocTags(this.apiDoc);
        if (visitor.visitApi) {
            const basePaths = this.basePathObs;
            visitor.visitApi({
                basePaths,
                getApiDoc,
            });
        }
    }
    loadSpec(filePath) {
        if (typeof filePath === 'string') {
            const origCwd = process.cwd();
            const specDir = path.resolve(origCwd, path.dirname(filePath));
            const absolutePath = path.resolve(origCwd, filePath);
            if (fs.existsSync(absolutePath)) {
                // Get document, or throw exception on error
                try {
                    process.chdir(specDir);
                    const docWithRefs = jsYaml.safeLoad(fs.readFileSync(absolutePath, 'utf8'), { json: true });
                    return json_ref_schema_1.$RefParser.bundle(docWithRefs);
                }
                finally {
                    process.chdir(origCwd);
                }
            }
            else {
                throw new Error(`${this.loggingPrefix}spec could not be read at ${filePath}`);
            }
        }
        return json_ref_schema_1.$RefParser.bundle(filePath);
    }
    copy(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
    sortApiDocTags(apiDoc) {
        if (apiDoc && Array.isArray(apiDoc.tags)) {
            apiDoc.tags.sort((a, b) => {
                return a.name < b.name ? -1 : 1;
            });
        }
    }
    getBasePathsFromServers(servers) {
        if (!servers || servers.length === 0) {
            return [new base_path_1.BasePath({ url: '' })];
        }
        const basePathsMap = {};
        for (const server of servers) {
            const basePath = new base_path_1.BasePath(server);
            basePathsMap[basePath.path] = basePath;
        }
        return Object.keys(basePathsMap).map(key => basePathsMap[key]);
    }
}
exports.OpenAPIFramework = OpenAPIFramework;
//# sourceMappingURL=index.js.map