"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Ajv = require("ajv");
const draftSchema = require("ajv/lib/refs/json-schema-draft-04.json");
const formats_1 = require("./formats");
const TYPE_JSON = 'application/json';
function createRequestAjv(openApiSpec, options = {}) {
    return createAjv(openApiSpec, options);
}
exports.createRequestAjv = createRequestAjv;
function createResponseAjv(openApiSpec, options = {}) {
    return createAjv(openApiSpec, options, false);
}
exports.createResponseAjv = createResponseAjv;
function createAjv(openApiSpec, options = {}, request = true) {
    const ajv = new Ajv(Object.assign(Object.assign({}, options), { schemaId: 'auto', allErrors: true, meta: draftSchema, formats: Object.assign(Object.assign({}, formats_1.formats), options.formats), unknownFormats: options.unknownFormats }));
    ajv.removeKeyword('propertyNames');
    ajv.removeKeyword('contains');
    ajv.removeKeyword('const');
    if (request) {
        ajv.removeKeyword('readOnly');
        ajv.addKeyword('readOnly', {
            modifying: true,
            compile: sch => {
                if (sch) {
                    return function validate(data, path, obj, propName) {
                        const isValid = !(sch === true && data != null);
                        delete obj[propName];
                        validate.errors = [
                            {
                                keyword: 'readOnly',
                                dataPath: path,
                                message: `is read-only`,
                                params: { readOnly: propName },
                            },
                        ];
                        return isValid;
                    };
                }
                return () => true;
            },
        });
    }
    else {
        // response
        ajv.removeKeyword('writeOnly');
        ajv.addKeyword('writeOnly', {
            modifying: true,
            compile: sch => {
                if (sch) {
                    return function validate(data, path, obj, propName) {
                        const isValid = !(sch === true && data != null);
                        validate.errors = [
                            {
                                keyword: 'writeOnly',
                                dataPath: path,
                                message: `is write-only`,
                                params: { writeOnly: propName },
                            },
                        ];
                        return isValid;
                    };
                }
                return () => true;
            },
        });
    }
    if (openApiSpec.components.schemas) {
        Object.entries(openApiSpec.components.schemas).forEach(([id, schema]) => {
            ajv.addSchema(schema, `#/components/schemas/${id}`);
        });
    }
    if (openApiSpec.components.requestBodies) {
        Object.entries(openApiSpec.components.requestBodies).forEach(([id, schema]) => {
            // TODO add support for content all content types
            ajv.addSchema(schema.content[TYPE_JSON].schema, `#/components/requestBodies/${id}`);
        });
    }
    return ajv;
}
//# sourceMappingURL=index.js.map